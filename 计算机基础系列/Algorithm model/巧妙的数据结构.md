## 单调栈

单调栈思想其实很简单，就是维护一个栈，使栈内的元素保持单调性（这个‘栈’可以直接用stack，也可以用数组来实现，具体情况具体判断）

难点在于什么情况下使用单调栈：这里就有两个例子：https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/

https://leetcode-cn.com/problems/create-maximum-number/

这两题的共同点是：**在一个较长（N）的数组中找到固定长度K的子序列，使得这个子序列最大（或者最小），这就可以用单调栈来解决。**

先看[第一题](https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/)（lc周赛第二题...都不会写...）刚开始的想法没有想到用单调栈，用的是优先队列，这个想法肯定是可以的，基于贪心思想，先把前n-k个元素都压进优先队列中，取出最小的，再将第n-k+1个元素压进去，看看能不能取（要在前一个取得元素的后边），重复，就可以得到最终答案，但时间复杂度不是很乐观

正解就是利用单调栈去模拟，看看还能扔掉多少个元素，然后去比较着扔就得到了最后的答案

## 差分数组

什么时候用到差分数组：对一段区间同时加上或减去X；如果用朴素的方法，我们需要去循环区间然后赋值，但使用差分数组我们只需要修改区间的边界值就行了

差分数组d[i] = a[i] - a[i-1] （我感觉这个式子没多大用，只是定义而已）

```c++
/*举个例子
原数组 : 2 2 2  1 1 1 2 2 2
差分数组 2 0 0 -1 0 0 1 0 0
可以看出，用差分数组来维护原数组，只需要在区间边界进行修改
差分数组 -> 原数组 ： 求一下前缀和
```

例题：https://leetcode-cn.com/problems/minimum-moves-to-make-array-complementary/ 

对某一区间[L, R]进行同一操作，对差分数组进行[L, R+1]操作